import Foundation
import UIKit
import UniformTypeIdentifiers

/// A private struct to hold listener information.
private struct Listener {
  let id: String
  let callback: (ShareEvent) -> Void
}

/// A singleton class responsible for detecting and dispatching shared items to JavaScript listeners.
class ShareSingleton {
  /// The shared singleton instance.
  static let shared = ShareSingleton()

  private var listeners: [Listener] = []
  private let appGroupId: String?
  private let userDefaultsKey = "NitroSharedItems"
  private let queue = DispatchQueue(label: "com.nitro.shareSingleton.queue")

  /// State to ensure `INITIAL_SHARED_ITEMS` is only sent once per app lifecycle.
  private var hasSentInitialItems = false

  private init() {
    if let infoDict = Bundle.main.infoDictionary, let groupId = infoDict["appGroupId"] as? String {
      self.appGroupId = groupId
    } else {
      self.appGroupId = nil
    }

    // Register to be notified when the app becomes active.
    // This is crucial for handling shares when the app is already running in the background ("warm start").
    NotificationCenter.default.addObserver(
      self,
      selector: #selector(appDidBecomeActive),
      name: UIApplication.didBecomeActiveNotification,
      object: nil
    )
  }

  /// Registers a callback from JavaScript to listen for share events.
  /// This also triggers the initial check for items shared while the app was closed ("cold start").
  func addListener(callback: @escaping (ShareEvent) -> Void) -> () -> Void {
    let id = UUID().uuidString
    let newListener = Listener(id: id, callback: callback)

    DispatchQueue.main.async { self.listeners.append(newListener) }

    // Check for data immediately upon listener registration.
    queue.async { self.checkForSharedData() }

    // Return a closure that will be used by JS to unsubscribe.
    return { [weak self] in
      DispatchQueue.main.async { self?.listeners.removeAll { $0.id == id } }
    }
  }

  /// The method called by the `didBecomeActive` notification.
  @objc private func appDidBecomeActive() {
    queue.async { self.checkForSharedData() }
  }

  /// Atomically reads, deletes, and processes shared data from UserDefaults.
  /// This is safe to be called multiple times from different triggers.
  private func checkForSharedData() {
    guard let appGroupId = self.appGroupId, let userDefaults = UserDefaults(suiteName: appGroupId) else { return }

    // Ensure we have the latest data from the other process.
    userDefaults.synchronize()

    guard let sharedData = userDefaults.array(forKey: self.userDefaultsKey) as? [[String: Any]], !sharedData.isEmpty else {
      // This is a normal case; no new items were shared.
      return
    }

    // CRITICAL: Atomically remove the data to prevent processing it more than once.
    userDefaults.removeObject(forKey: self.userDefaultsKey)
    userDefaults.synchronize()

    let sharedItems = sharedData.compactMap { self.createSharedItem(from: $0) }
    guard !sharedItems.isEmpty else { return }

    // Determine the correct event type to send.
    let eventType: ShareEventType = self.hasSentInitialItems ? .sharedItems : .initialSharedItems
    if !self.hasSentInitialItems { self.hasSentInitialItems = true }

    let eventData = ShareEventData(items: sharedItems, totalCount: Double(sharedItems.count))
    let event = ShareEvent(event: eventType, data: eventData)

    // Dispatch the event to all registered listeners on the main thread.
    DispatchQueue.main.async {
      self.listeners.forEach { $0.callback(event) }
    }
  }

  /// Creates a type-safe `SharedItem` struct from a dictionary.
  private func createSharedItem(from dict: [String: Any]) -> SharedItem? {
    guard let typeString = dict["type"] as? String,
          let type = ShareItemType(fromString: typeString) else { return nil }

    // This initializer is generated by `nitro-codegen` based on your TypeScript spec.
    return SharedItem(
      type: type,
      content: dict["content"] as? String,
      title: dict["title"] as? String,
      description: dict["description"] as? String,
      url: dict["url"] as? String,
      filePath: dict["filePath"] as? String,
      mimeType: dict["mimeType"] as? String,
      fileSize: dict["fileSize"] as? Double,
      timestamp: dict["timestamp"] as? Double ?? Date().timeIntervalSince1970 * 1000,
      sourceApp: dict["sourceApp"] as? String,
      thumbnailPath: dict["thumbnailPath"] as? String,
      duration: dict["duration"] as? Double,
      width: dict["width"] as? Double,
      height: dict["height"] as? Double
    )
  }
}
